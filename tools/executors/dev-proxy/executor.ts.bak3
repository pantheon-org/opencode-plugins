import { spawn, spawnSync } from 'node:child_process';
import path from 'node:path';
import { type ExecutorContext, runExecutor as nxRunExecutor, type ProjectConfiguration } from '@nx/devkit';

interface DevProxyOptions {
  plugins?: string[];
  symlinkRoot?: string;
  apply?: boolean;
  __runExecutor?: typeof nxRunExecutor;
  __spawnSync?: typeof spawnSync;
  __noExit?: boolean;
}

interface ExecutorResult {
  success: boolean;
}

interface ResolvedProject {
  name: string;
  root?: string;
  config?: ProjectConfiguration;
}

/**
 * Nx executor for running dev proxy with build watchers
 * @param options - Executor options including plugin names and symlink configuration
 * @param context - Nx executor context
 * @yields Executor results during execution
 */
// eslint-disable-next-line max-statements, complexity
async function* runExecutor(options: DevProxyOptions, context: ExecutorContext): AsyncGenerator<ExecutorResult> {
  const workspaceRoot = context.root;

  const requestedPlugins =
    options.plugins && options.plugins.length > 0 ? options.plugins : context.projectName ? [context.projectName] : [];

  if (requestedPlugins.length === 0) {
    console.error('No project specified for dev-proxy (provide --plugins or run from a project context)');
    yield { success: false };
    return;
  }

  // Resolve projects - simplified to just use the names
  const resolved: ResolvedProject[] = requestedPlugins.map((name) => ({ name }));

  // Start watchers
  const stopFns: Array<() => Promise<void>> = [];

  // Choose runExecutor implementation: allow injection for tests
  const runExecutorImpl = options.__runExecutor ?? nxRunExecutor;
  const spawnSyncImpl = options.__spawnSync ?? spawnSync;

  // biome-ignore lint/suspicious/noConsole: Intentional logging for dev-proxy executor
  console.info('dev-proxy: workspaceRoot=', workspaceRoot);

  for (const r of resolved) {
    const projName = r.name;
    let started = false;

    if (runExecutorImpl) {
      try {
        const iterator = await runExecutorImpl(
          { project: projName, target: 'build', configuration: undefined },
          { watch: true },
          context,
        );

        if (iterator) {
          const it = iterator as AsyncIterable<{ success: boolean }> & { return?: () => Promise<void> };
          if (Symbol.asyncIterator in it) {
            (async () => {
              try {
                for await (const out of it) {
                  if (!out || !out.success) console.error(`Build for ${projName} reported failure`);
                }
              } catch (err) {
                console.error(`runExecutor iterator error for ${projName}:`, err);
              }
            })();
          }
          stopFns.push(async () => {
            try {
              if (typeof it.return === 'function') await it.return();
            } catch {
              // Failed to stop iterator
            }
          });
          // biome-ignore lint/suspicious/noConsole: Intentional logging for dev-proxy executor
          console.info(`Started build target for ${projName} via @nx/devkit.runExecutor`);
          started = true;
        }
      } catch (err) {
        console.warn(`runExecutor failed for ${projName}:`, String(err));
      }
    }

    if (!started) {
      try {
        // biome-ignore lint/suspicious/noConsole: Intentional logging for dev-proxy executor
        console.info(`Falling back to CLI watcher for ${projName}`);
        const child = spawn('bunx', ['nx', 'run', `${projName}:build`, '--watch'], {
          stdio: 'inherit',
          cwd: workspaceRoot,
        });
        stopFns.push(async () => {
          try {
            child.kill();
          } catch {
            // Failed to kill process
          }
        });
      } catch (err) {
        console.warn(`Failed to start CLI watcher for ${projName}:`, String(err));
      }
    }
  }

  // Spawn the runtime dev script
  const script = path.join(workspaceRoot, 'tools', 'dev', 'opencode-dev.ts');
  const args: string[] = [];
  if (options.symlinkRoot) args.push('--symlink-root', options.symlinkRoot);
  if (options.apply === false) args.push('--no-apply');
  args.push(...requestedPlugins);

  // biome-ignore lint/suspicious/noConsole: Intentional logging for dev-proxy executor
  console.info('Running dev proxy runtime:', ['bunx', 'tsx', script, ...args].join(' '));

  // Ensure cleanup on SIGINT
  let exiting = false;
  const sigintHandler = async () => {
    if (exiting) return;
    exiting = true;
    // biome-ignore lint/suspicious/noConsole: Intentional logging for dev-proxy executor
    console.info('\nInterrupted. Stopping build watchers and exiting...');
    for (const fn of stopFns) {
      try {
        await fn();
      } catch {
        // Failed to stop watcher
      }
    }
    if (!options.__noExit) {
      process.exit(0);
    }
  };
  process.on('SIGINT', sigintHandler);

  // Run runtime script synchronously
  const res = spawnSyncImpl('bunx', ['tsx', script, ...args], { stdio: 'inherit', cwd: workspaceRoot });

  // Ensure watchers are terminated when runtime exits
  for (const fn of stopFns) {
    try {
      fn();
    } catch {
      // Failed to terminate watcher
    }
  }

  if (res?.error) {
    console.error('Failed to run dev proxy runtime', res.error);
    yield { success: false };
    return;
  }
  yield { success: res?.status === 0 };
}

export default runExecutor;
